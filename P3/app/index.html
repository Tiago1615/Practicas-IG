<!DOCTYPE html>
<html>
  <!-- STEP 1: Prepare the canvas -->
  <head>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, user-scalable=no" />

    <!-- librería GUI -->
    <script type="text/javascript" src="dat.gui.min.js"></script>
    
    <!-- librería Matrices -->
    <script type="text/javascript" src="gl-matrix-min.js"></script>
  </head>

  <body>
    <canvas width="350" height="350" id="my_Canvas"></canvas>

    <!-- vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
      #version 300 es
      precision mediump float;

      in vec2 aCoordinates;
      uniform mat4 uModelMatrix;

      void main(void) {
        gl_Position = uModelMatrix * vec4(aCoordinates, 0.0, 1.0);
        gl_PointSize = 10.0;
      }
    </script>

    <!-- fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
      #version 300 es
      precision mediump float;

      out vec4 fragColor;
      uniform vec4 uColor;

      void main(void) {
        fragColor = uColor;
      }
    </script>

    <script type="module">
      import {CelestialBodies} from "./Classes/celestialBodies.js";
      
      var gl;
      var canvas;
      var vertex_buffer;
      var colorLocation;
      var modelMatrix;

      var modelMatrixLoc;
      const { vec2, vec3, mat3, mat4 } = glMatrix;

      var settings = {
        translateX: 0.0,
        translateY: 0.0,
        scale: 1.0,
        rotateX: 0.0,
        rotateY: 0.0,
        rotateZ: 0.0,
      };
      var gui = new dat.GUI();
      gui.add(settings, "translateX", -1.0, 1.0, 0.01);
      gui.add(settings, "translateY", -1.0, 1.0, 0.01);
      gui.add(settings, "scale", 0.1, 2.0, 0.01);
      gui.add(settings, "rotateX", -180, 180);
      gui.add(settings, "rotateY", -180, 180);
      gui.add(settings, "rotateZ", -180, 180);

      var sun = new CelestialBodies(0, 0, 0.15, 0.15, [1, 1, 0, 1], 0.0, 0.0);
      
      var mercury = new CelestialBodies(0.2, 0, 0.06, 0.06, [0.3, 0.32, 0.2, 1], 0.0, 0.0);
      
      var venus = new CelestialBodies(0.34, 0, 0.07, 0.07, [0.5, 0.6, 0.3, 1], 0.0, 0.0);
      
      var earth = new CelestialBodies(0.55, 0, 0.08, 0.08, [0.3, 0.4, 1, 1], 0.0, 0.0);
      var moon = new CelestialBodies(0.1, 0, 0.03, 0.03, [1, 1, 1, 1], 0.0, 0.0);
      
      var mars = new CelestialBodies(0.83, 0, 0.09, 0.09, [1, 0.33, 0.2, 1], 0.0, Math.PI/6);
      
      var jupiter = new CelestialBodies(0.99, 0, 0.12, 0.12, [1, 0.8, 0, 1], 0.0, 0.0);
      var europa = new CelestialBodies(0.1, 0, 0.04, 0.04, [1, 0.85, 0.6,1], 0.0, 0.0);
      
      var saturn = new CelestialBodies(1.23, 0, 0.099, 0.099, [1, 1, 0, 1], 0.0, 0.0);
      var titan = new CelestialBodies(0.1, 0, 0.04, 0.04, [1, 0.9, 0, 1], 0.0, 0.0);
      
      var uranus = new CelestialBodies(1.43, 0, 0.096, 0.096, [0.4, 0.95, 0.8, 1], 0.0, Math.PI/4);
      
      var neptune = new CelestialBodies(1.7, 0, 0.094, 0.094, [0, 0, 1, 1], 0.0, 0.0);
      var triton = new CelestialBodies(0.1, 0, 0.04, 0.04, [1.0, 0.894, 0.941, 1], 0.0, 0.0);
      var thalasa = new CelestialBodies(0.17, 0, 0.04, 0.05, [0.35, 0.35, 0.35, 1], 0.0, 0.0);

      var matrixStack = [];
      function glPushMatrix() {
        const matrix = mat4.create();
        mat4.copy(matrix, modelMatrix);
        matrixStack.push(matrix);
      }

      function glPopMatrix() {
        modelMatrix = matrixStack.pop();
      }

      function init() {
        // ============ STEP 1: Creating a canvas=================
        canvas = document.getElementById("my_Canvas");
        gl = canvas.getContext("webgl2");

        //========== STEP 2: Create and compile shaders ==========

        // Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        // Attach vertex shader source code
        var script = document.getElementById("vertex-shader");
        var shaderString = script.text.trim();
        gl.shaderSource(vertShader, shaderString);

        // Compile the vertex shader
        gl.compileShader(vertShader);

        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        script = document.getElementById("fragment-shader");
        shaderString = script.text.trim();
        gl.shaderSource(fragShader, shaderString);

        // Compile the fragmentt shader
        gl.compileShader(fragShader);

        // Create a shader program object to store
        // the combined shader program
        var shaderProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both programs
        gl.linkProgram(shaderProgram);

        // Use the combined shader program object
        gl.useProgram(shaderProgram);

        //======== STEP 3: Create buffer objects and associate shaders ========

        // Create an empty buffer object to store the vertex buffer
        vertex_buffer = gl.createBuffer();

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Get the attribute location
        var coordLocation = gl.getAttribLocation(shaderProgram, "aCoordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coordLocation, 2, gl.FLOAT, false, 0, 0);

        // Enable the attribute
        gl.enableVertexAttribArray(coordLocation);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // look up uniform locations
        colorLocation = gl.getUniformLocation(shaderProgram, "uColor");
        modelMatrixLoc = gl.getUniformLocation(shaderProgram, "uModelMatrix");

        // Set a random color.
        //gl.uniform4f(colorLocation, 1, 0, 0, 1);

        // renderizamos el frame
        render();
      }

      function render() {
        //========= STEP 4: Create the geometry and draw ===============

        // Clear the canvas
        gl.clearColor(0.1, 0.1, 0.1, 1.0);

        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Set the model Matrix.
        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);
        mat4.translate(modelMatrix, modelMatrix, [
          settings.translateX,
          settings.translateY,
          0,
        ]);
        mat4.scale(modelMatrix, modelMatrix, [settings.scale, settings.scale, 1]);
        mat4.rotateX(modelMatrix, modelMatrix, (settings.rotateX / 180) * Math.PI);
        mat4.rotateY(modelMatrix, modelMatrix, (settings.rotateY / 180) * Math.PI);
        mat4.rotateZ(modelMatrix, modelMatrix, (settings.rotateZ / 180) * Math.PI);
        gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);

        //draw sun
        glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [sun.width, sun.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, sun.color);
          drawSquare();
        glPopMatrix();

        //draw mercury
        glPushMatrix();
          mercury.angle += 0.01;
          mat4.rotateZ(modelMatrix, modelMatrix, mercury.angle);
          mat4.translate(modelMatrix, modelMatrix, [mercury.x, mercury.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [mercury.width, mercury.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, mercury.color);
          drawSquare();
        glPopMatrix();
        
        //draw mercurys orbit
        glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [mercury.x, mercury.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, mercury.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw venus
        glPushMatrix();
          venus.angle += 0.01;
          mat4.rotateZ(modelMatrix, modelMatrix, venus.angle);
          mat4.translate(modelMatrix, modelMatrix, [venus.x, venus.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [venus.width, venus.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, venus.color);
          drawSquare();
        glPopMatrix();
        
        //draw venus' orbit
        glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [venus.x, venus.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, venus.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw earth
        glPushMatrix();
          earth.angle += 0.01;
          mat4.rotateZ(modelMatrix, modelMatrix, earth.angle);
          mat4.translate(modelMatrix, modelMatrix, [earth.x, earth.y, 0]);
          glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [earth.width, earth.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, earth.color);
          drawSquare();

        //draw moon
          moon.angle += 0.01;
          glPopMatrix();
          mat4.rotateZ(modelMatrix, modelMatrix, moon.angle);
          glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, [moon.x, moon.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [moon.width, moon.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, moon.color);
          drawSquare();
        

        //draw moons orbit
          glPopMatrix();
          mat4.scale(modelMatrix, modelMatrix, [moon.x, moon.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, moon.color);
          drawCircle(100);

        glPopMatrix();
        
        //draw earths orbit
        glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [earth.x, earth.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, earth.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw mars
        glPushMatrix();
          mars.angle += 0.01;
          mat4.rotateX(modelMatrix, modelMatrix, mars.inclination);
          mat4.rotateZ(modelMatrix, modelMatrix, mars.angle);
          mat4.translate(modelMatrix, modelMatrix, [mars.x, mars.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [mars.width, mars.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, mars.color);
          drawSquare();
        glPopMatrix();
        
        //draw mars' orbit
        glPushMatrix();
          mat4.rotateX(modelMatrix, modelMatrix, mars.inclination)
          mat4.scale(modelMatrix, modelMatrix, [mars.x, mars.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, mars.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw jupiter
        glPushMatrix();
          jupiter.angle += 0.01;
          mat4.rotateZ(modelMatrix, modelMatrix, jupiter.angle);
          mat4.translate(modelMatrix, modelMatrix, [jupiter.x, jupiter.y, 0]);
          glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [jupiter.width, jupiter.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, jupiter.color);
          drawSquare();
        
          //draw europa
          europa.angle += 0.01;
          glPopMatrix();
          mat4.rotateZ(modelMatrix, modelMatrix, europa.angle);
          glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, [europa.x, europa.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [europa.width, europa.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, europa.color);
          drawSquare();
        
          //draw europas orbit
          glPopMatrix();
          mat4.scale(modelMatrix, modelMatrix, [europa.x, europa.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, europa.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw jupiters orbit
        glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [jupiter.x, jupiter.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, jupiter.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw saturn
        glPushMatrix();
          saturn.angle += 0.01;
          mat4.rotateZ(modelMatrix, modelMatrix, saturn.angle);
          mat4.translate(modelMatrix, modelMatrix, [saturn.x, saturn.y, 0]);
          glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [saturn.width, saturn.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, saturn.color);
          drawSquare();
        
          //draw titan
          titan.angle += 0.01;
          glPopMatrix();
          mat4.rotateZ(modelMatrix, modelMatrix, titan.angle);
          glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, [titan.x, titan.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [titan.width, titan.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, titan.color);
          drawSquare();
        
          //draw titans orbit
          glPopMatrix();
          mat4.scale(modelMatrix, modelMatrix, [titan.x, titan.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, titan.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw saturns orbit
        glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [saturn.x, saturn.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, saturn.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw uranus
        glPushMatrix();
          uranus.angle += 0.01;
          mat4.rotateY(modelMatrix, modelMatrix, uranus.inclination);
          mat4.rotateZ(modelMatrix, modelMatrix, uranus.angle);
          mat4.translate(modelMatrix, modelMatrix, [uranus.x, uranus.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [uranus.width, uranus.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, uranus.color);
          drawSquare();
        glPopMatrix();
        
        //draw uranus' orbit
        glPushMatrix();
          mat4.rotateY(modelMatrix, modelMatrix, uranus.inclination);
          mat4.scale(modelMatrix, modelMatrix, [uranus.x, uranus.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, uranus.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw neptune
        glPushMatrix();
          neptune.angle += 0.01;
          mat4.rotateZ(modelMatrix, modelMatrix, neptune.angle);
          mat4.translate(modelMatrix, modelMatrix, [neptune.x, neptune.y, 0]);
          glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [neptune.width, neptune.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, neptune.color);
          drawSquare();
        
          //draw triton
          triton.angle += 0.01;
          glPopMatrix();
          glPushMatrix();
          mat4.rotateZ(modelMatrix, modelMatrix, triton.angle);
          glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, [triton.x, triton.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [triton.width, triton.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, triton.color);
          drawSquare();
        
          //draw tritons orbit
          glPopMatrix();
          mat4.scale(modelMatrix, modelMatrix, [triton.x, triton.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, triton.color);
          drawCircle(100);
        
          //draw thalasa
          thalasa.angle += 0.01;
          glPopMatrix();
          mat4.rotateZ(modelMatrix, modelMatrix, thalasa.angle);
          glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, [thalasa.x, thalasa.y, 0]);
          mat4.scale(modelMatrix, modelMatrix, [thalasa.width, thalasa.height, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, thalasa.color);
          drawSquare();
        
          //draw thalasas orbit
          glPopMatrix();
          mat4.scale(modelMatrix, modelMatrix, [thalasa.x, thalasa.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, thalasa.color);
          drawCircle(100);
        glPopMatrix();
        
        //draw neptunes orbit
        glPushMatrix();
          mat4.scale(modelMatrix, modelMatrix, [neptune.x, neptune.x, 1]);
          gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
          gl.uniform4fv(colorLocation, neptune.color);
          drawCircle(100);
        glPopMatrix();

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // empezamos bucle animación
        window.requestAnimationFrame(render);
      }

      function drawSquare() {
        var v = new Float32Array([
          -0.5, 0.5, 0.5, 0.5, -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5,
        ]);
        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
      
      function drawCircle(numVertex){
        let vertexes = [];
        let distance = 1.0;
        
        for (let i = 0; i < numVertex; i++){
          let angle = (i/numVertex) * 2 * Math.PI;
          
          let x = distance * Math.cos(angle);
          let y = distance * Math.sin(angle);
          
          vertexes.push(x,y);
        }
        
        let v = new Float32Array(vertexes);
        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
        gl.drawArrays(gl.LINE_LOOP, 0, numVertex);
      }

      // Call init once the document has loaded
      window.onload = init;
    </script>
  </body>
</html>
