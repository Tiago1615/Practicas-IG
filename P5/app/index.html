<!DOCTYPE html>
<html>
  <!-- STEP 1: Prepare the canvas -->
  <head>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <script type="text/javascript" src="dat.gui.min.js"></script>
    <script src="gl-matrix-min.js"></script>
  </head>

  <body>
    <canvas width="500" height="500" id="my_Canvas"></canvas>

    <!-- vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
            #version 300 es
            precision mediump float;

            in vec3 aCoordinates;
            in vec3 aVertexNormals;
            out vec3 vNormal;
            out vec3 vEyeVector;
            out vec3 vLightDirection;
            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform vec4 uLightPosition;
            uniform bool uFixedLight;

            void main(void) {
              // saving vertex after transformations BEFORE PERSPECTIVE
              vec4 vertex = uModelMatrix * vec4(aCoordinates, 1.0);

              gl_Position = uViewMatrix * vertex;

              // compute normal vector
              vNormal = vec3(uModelMatrix * vec4(aVertexNormals, 0.0));

              // compute vector from vertex to viewer
              vEyeVector = -vertex.xyz;

              // compute vector from vertex to light
              vec4 light;
              if (uFixedLight == true){
                light = uLightPosition;
              }
              else{
                light = uModelMatrix * uLightPosition;
              }
              vLightDirection = light.xyz - vertex.xyz;
            }
    </script>

    <!-- fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
      #version 300 es
      precision mediump float;

      out vec4 fragColor;
      in vec3 vNormal;
      in vec3 vEyeVector;
      in vec3 vLightDirection;
      
      uniform vec4 uColor;
      uniform vec3 uDiffuseMaterial;
      uniform vec3 uSpecularMaterial;
      uniform float uShininess;

      void main(void) {
        // computing diffuse component
        vec3 N = normalize(vNormal);
        
        vec3 L = normalize(vLightDirection);
        
        vec3 diffuseMaterial = uDiffuseMaterial;
        
        float diffuse = max(dot(N, L), 0.0);
        
        vec4 Idif = vec4(diffuse*diffuseMaterial,1);

        // compute specular component
        float NL = dot(N,L);
        
        vec4 Ispec = vec4(0,0,0,1);
        
        if (NL>0.0) {
           vec3 R = 2.0*N*NL-L;
           float shininess = uShininess;
           vec3 specularMaterial = uSpecularMaterial;
           vec3 V = normalize(vEyeVector);
           float specular = pow(max(dot(R, V), 0.0), shininess);
           Ispec = vec4(specular * specularMaterial, 1);
        }
        
        // computing ambient component
        vec4 Iamb = vec4(0,0,0.4,1);
        
        // calculamos color final
        fragColor = Iamb + Idif + Ispec;
        
        fragColor = min(fragColor, vec4(1,1,1,1));
      }
    </script>

    <script type="module">
      const { vec2, vec3, mat3, mat4 } = glMatrix;

      var eye;
      var v;
      
      var gl;
      var canvas;
      var vertex_buffer;
      var index_buffer;
      var colorLocation;
      var modelMatrixLoc;
      var viewMatrixLoc;
      var modelMatrix;
      var viewMatrix;

      var matrixStack = [];

      var rotateX = 0, rotateY = 0;
      var mouseX, mouseY;

      var zoomFactor = 1;
      var normalsLoc;
      var normal_buffer;
      
      // Obtener las ubicaciones de los uniformes para la GUI
      var diffuseMaterialLoc;
      var specularMaterialLoc;
      var shininessLoc;
      var lightPositionLoc;
      var fixedLightLoc;
      
      var settings = {
        diffuseMaterial: [0, 1, 0],
        specularMaterial: [1, 0, 0],
        shininess: 10.0,
        lightPosition: {x: 10, y: 10, z:10},
        fixedLight: true,
      };
      

      
      var gui = new dat.GUI();
      gui.addColor(settings, 'diffuseMaterial').name('Diffuse Material');
      gui.addColor(settings, 'specularMaterial').name('Specular Material');
      gui.add(settings, 'shininess', 1, 100).name('Shininess');
      gui.add(settings.lightPosition, "x", -40, 40).name("Light X");
      gui.add(settings.lightPosition, "y", -40, 40).name("Light Y");
      gui.add(settings.lightPosition, "z", -40, 40).name("Light Z");
      gui.add(settings, "fixedLight").name("Fixed light");

      function glPushMatrix() {
        const matrix = mat4.create();
        mat4.copy(matrix, modelMatrix);
        matrixStack.push(matrix);
      }

      function glPopMatrix() {
        modelMatrix = matrixStack.pop();
      }

      function drawSquare() {
        v = new Float32Array([
          -0.5, 0.5, 0.5, 0.5, -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5,
        ]);
        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      function init() {
        // ============ STEP 1: Creating a canvas=================
        canvas = document.getElementById("my_Canvas");
        gl = canvas.getContext("webgl2");

        //========== STEP 2: Create and compile shaders ==========

        // Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        // Attach vertex shader source code
        var script = document.getElementById("vertex-shader");
        var shaderString = script.text.trim();
        gl.shaderSource(vertShader, shaderString);

        // Compile the vertex shader
        gl.compileShader(vertShader);

        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        script = document.getElementById("fragment-shader");
        shaderString = script.text.trim();
        gl.shaderSource(fragShader, shaderString);

        // Compile the fragmentt shader
        gl.compileShader(fragShader);
        if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
          console.error("vertShader: " + gl.getShaderInfoLog(fragShader));
          return null;
        }

        if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
          console.error("vertShader: " + gl.getShaderInfoLog(vertShader));
          return null;
        }

        // Create a shader program object to store
        // the combined shader program
        var shaderProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both programs
        gl.linkProgram(shaderProgram);

        // Use the combined shader program object
        gl.useProgram(shaderProgram);

        //======== STEP 3: Create buffer objects and associate shaders ========

        // Create an empty buffer object to store the vertex buffer
        vertex_buffer = gl.createBuffer();
        normal_buffer = gl.createBuffer();

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Get the attribute location
        var coordLocation = gl.getAttribLocation(shaderProgram, "aCoordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coordLocation, 3, gl.FLOAT, false, 0, 0);
        
        // look up uniform locations
        colorLocation = gl.getUniformLocation(shaderProgram, "uColor");

        modelMatrixLoc = gl.getUniformLocation(shaderProgram, "uModelMatrix");
        viewMatrixLoc = gl.getUniformLocation(shaderProgram, "uViewMatrix");
        normalsLoc = gl.getAttribLocation(shaderProgram, "aVertexNormals");
        
        // Obtener las ubicaciones de los uniformes
        diffuseMaterialLoc = gl.getUniformLocation(shaderProgram, 'uDiffuseMaterial');
        specularMaterialLoc = gl.getUniformLocation(shaderProgram, 'uSpecularMaterial');
        shininessLoc = gl.getUniformLocation(shaderProgram, 'uShininess');
        lightPositionLoc = gl.getUniformLocation(shaderProgram, 'uLightPosition');
        fixedLightLoc = gl.getUniformLocation(shaderProgram, 'uFixedLight');

        // Enable the attribute
        gl.enableVertexAttribArray(coordLocation);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindBuffer(gl.ARRAY_BUFFER, normal_buffer);
        gl.vertexAttribPointer(normalsLoc, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(normalsLoc);

        // create index buffer
        index_buffer = gl.createBuffer();
        gl.enable(gl.DEPTH_TEST);

        render();
      }

      function render(time) {

        // Clear the canvas
        gl.clearColor(1, 0.8, 0.9, 1.0);

        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);

        // Set the model Matrix.
        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);

        // perspectiva
        viewMatrix = mat4.create();
        mat4.perspective(viewMatrix, Math.PI / 4, 1, 1, 30);
        gl.uniformMatrix4fv(viewMatrixLoc, false, viewMatrix);
        
        
        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);
        /*eye = [player.x, player.y, player.z];
        v = [player.x + Math.cos(player.ori), player.y, player.z + Math.sin(player.ori)];
        mat4.lookAt(modelMatrix,
          eye,
          v,
          [0,1,0] // up vector
        );*/
        

        mat4.lookAt(modelMatrix, [0, 0, 3], [0, 0, 0], [0, 1, 0]);

        // mouse rotations
        mat4.scale(modelMatrix, modelMatrix, [
          zoomFactor,
          zoomFactor,
          zoomFactor,
        ]);
        mat4.rotateX(modelMatrix, modelMatrix, rotateX);
        mat4.rotateY(modelMatrix, modelMatrix, rotateY);
        
        //Actualizar los valores de los uniformes desde la GUI
        gl.uniform3fv(diffuseMaterialLoc, settings.diffuseMaterial);
        gl.uniform3fv(specularMaterialLoc, settings.specularMaterial);
        gl.uniform1f(shininessLoc, settings.shininess);
        gl.uniform4f(lightPositionLoc, settings.lightPosition.x, settings.lightPosition.y, settings.lightPosition.z, 1.0);
        gl.uniform1i(fixedLightLoc, settings.fixedLight ? 1 : 0);

        // draw cube
        glRenderSphereIBO(20);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        // empezamos bucle animación
        window.requestAnimationFrame(render);
      }

      function glRenderCubeIBO(colorEdges, colorCube) {
        glPushMatrix();
        mat4.translate(modelMatrix, modelMatrix, [-0.5, 0, -0.5]);
        gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
        // create vertices
        var arrayV = new Float32Array([
          0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1,
          1,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, arrayV, gl.STATIC_DRAW);

        // draw edges
        var arrayI = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayI, gl.STATIC_DRAW);
        gl.uniform4fv(colorLocation, colorEdges);
        gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 0);

        // draw faces
        var arrayF = new Uint16Array([
        1,0,3, 1,3,2, // cara trasera
        4,5,6, 4,6,7, // cara delantera
        7,6,2, 7,2,3, // cara superior
        0,1,5, 0,5,4, // cara inferior
        5,1,2, 5,2,6, // cara derecha
        0,4,7, 0,7,3, // cara izquierda
                                 ]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayF, gl.STATIC_DRAW);
        gl.uniform4fv(colorLocation, colorCube);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        glPopMatrix();
      }

      window.onload = init;
      
      document.onmousemove = onMouseMove;
      document.onmousedown = onMouseDown;
      document.onwheel = zoom;
      document.onkeydown = onKeyDown;

      function onKeyDown(key) {
       switch (key.keyCode) {
         // W
         case 87: {
           player.x = player.x + 0.1 * Math.cos(player.ori);
           player.z = player.z + 0.1 * Math.sin(player.ori);
           break;
         }
         // S
         case 83: {
           player.x = player.x - 0.1 * Math.cos(player.ori);
           player.z = player.z - 0.1 * Math.sin(player.ori);
           break;
         }
         // A
         case 65: {
         player.ori -= 0.02;
         break;
         }
         // D
         case 68: {
           player.ori += 0.02;
           break;
         }
       }
      }

      function onMouseDown(e) {
        if (e.buttons == 1 && e.srcElement == canvas) {
          mouseX = e.pageX;
          mouseY = e.pageY;
        }
      }

      function onMouseMove(e) {
        if (e.buttons == 1 && e.srcElement == canvas) {
          rotateY = rotateY + (e.pageX - mouseX) * 0.01;
          rotateX = rotateX + (e.pageY - mouseY) * 0.01;
          mouseX = e.pageX;
          mouseY = e.pageY;
          //console.log("move = ("+rotateX+","+rotateY+")");
        }
      }

      function zoom(e) {
        if (e.deltaY < 0) zoomFactor *= 1.1;
        else zoomFactor *= 0.9;
      }

      function glRenderSphereIBO(n) {
        glPushMatrix();
        mat4.scale(modelMatrix, modelMatrix, [0.7, 0.7, 0.7]);
        gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
        // compute vertices
        var coords = new Float32Array(6 * n * n);
        var step = Math.PI / n;
        var R = 1;
        var k = 0;
        for (var i = 1; i < n; i++) {
          var tita = -Math.PI / 2 + i * step;
          for (var j = 0; j < 2 * n; j++) {
            var alpha = j * step;
            coords[k++] = R * Math.cos(tita) * Math.cos(alpha);
            coords[k++] = R * Math.cos(tita) * Math.sin(alpha);
            coords[k++] = R * Math.sin(tita);
          }
        }

        var normals = coords;

        // compute faces
        var arrayIFaces = new Uint16Array((4 * n + 2) * n);
        k = 0;
        for (i = 0; i < n - 2; i++) {
          for (j = 0; j < 2 * n; j++) {
            arrayIFaces[k++] = 2 * n * (i + 1) + j;
            arrayIFaces[k++] = 2 * n * i + j;
          }
          arrayIFaces[k++] = 2 * n * (i + 1);
          arrayIFaces[k++] = 2 * n * i;
        }
        // pass data to GPU
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, normal_buffer);
        gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayIFaces, gl.STATIC_DRAW);

        // draw meshes
        for (i = 0; i < n - 2; i++)
          gl.drawElements(
            gl.TRIANGLE_STRIP,
            4 * n + 2,
            gl.UNSIGNED_SHORT,
            2 * i * (4 * n + 2)
          );

        glPopMatrix();
      }
    </script>
  </body>
</html>
