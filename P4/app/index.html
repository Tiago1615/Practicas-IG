<!DOCTYPE html>
<html>
  <!-- STEP 1: Prepare the canvas -->
  <head>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, user-scalable=no" />

    <!-- librería GUI -->
    <script type="text/javascript" src="dat.gui.min.js"></script>
    <script type="text/javascript" src="gl-matrix-min.js"></script>
  </head>

  <body>
    <canvas width="350" height="350" id="my_Canvas"></canvas>
    <div id="controls-container">
      <div id="controls">
        <p>Control keys:</p>
        <p>W/S Move forwards or backwards</p>
        <p>A/D Look to the right or to the left</p>
        <p>E Shoot bullets!</p>
        <p>Spacebar to jump</p>
      </div>
    </div>

    <!-- vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
      #version 300 es
      precision mediump float;

      in vec3 aCoordinates;
      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;

      void main(void) {
        gl_Position = uViewMatrix * uModelMatrix * vec4(aCoordinates, 1.0);
        gl_PointSize = 10.0;
        //gl_Position.z *= -1.0;
      }
    </script>

    <!-- fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        out vec4 fragColor;
        uniform vec4 uColor;

        void main(void) {
          //fragColor = vec4(1,0,1,1);
          fragColor = uColor;
      }
    </script>

    <script type="module">
      import {Cube, Enemy} from "./Classes.js";
      import {cube1,
              cube2,
              cube3,
              cube4,
              cube5,
              cube6,
              cube7,
              cube8,
              cube9,
              cube10,
              cube11,
              cube12,
              cube13,
              enemy1,
              enemy2,
              enemy3,
             } from "./vars.js";
      var canvas;
      var gl;
      var vertex_buffer;
      var index_buffer;
      var colorLocation;
      var rotateX = 0,rotateY = 0;
      var mouseX, mouseY;
      var zoomFactor = 1;
      var modelMatrix;
      var viewMatrix;
      var viewMatrixLoc;
      var eye;
      var v;
      var bullets = [];
      
      
      var player = {
       x: 0, y: 0.5, z: 10, ori:-Math.PI/2, jumpSpeed: 0,
       isJumping: false,
      };
      
      var matrixStack = [];

      function glPushMatrix() {
        const matrix = mat4.create();
        mat4.copy(matrix, modelMatrix);
        matrixStack.push(matrix);
      }

      function glPopMatrix() {
        modelMatrix = matrixStack.pop();
      }

      const { vec2, vec3, mat3, mat4 } = glMatrix;

      var modelMatrixLoc;

      function init() {
        // ============ STEP 1: Creating a canvas=================
        canvas = document.getElementById("my_Canvas");
        gl = canvas.getContext("webgl2");

        //========== STEP 2: Create and compile shaders ==========

        // Create a vertex shader object
        var vertShader = gl.createShader(gl.VERTEX_SHADER);

        // Attach vertex shader source code
        var script = document.getElementById("vertex-shader");
        var shaderString = script.text.trim();
        gl.shaderSource(vertShader, shaderString);

        // Compile the vertex shader
        gl.compileShader(vertShader);

        // Create fragment shader object
        var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

        // Attach fragment shader source code
        script = document.getElementById("fragment-shader");
        shaderString = script.text.trim();
        gl.shaderSource(fragShader, shaderString);

        // Compile the fragmentt shader
        gl.compileShader(fragShader);

        // Create a shader program object to store
        // the combined shader program
        var shaderProgram = gl.createProgram();

        // Attach a vertex shader
        gl.attachShader(shaderProgram, vertShader);

        // Attach a fragment shader
        gl.attachShader(shaderProgram, fragShader);

        // Link both programs
        gl.linkProgram(shaderProgram);

        // Use the combined shader program object
        gl.useProgram(shaderProgram);

        //======== STEP 3: Create buffer objects and associate shaders ========

        // Create an empty buffer object to store the vertex buffer
        vertex_buffer = gl.createBuffer();

        // create index buffer
        index_buffer = gl.createBuffer();

        // Bind vertex buffer object
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // Get the attribute location
        var coordLocation = gl.getAttribLocation(shaderProgram, "aCoordinates");

        // Point an attribute to the currently bound VBO
        gl.vertexAttribPointer(coordLocation, 3, gl.FLOAT, false, 0, 0);

        // Enable the attribute
        gl.enableVertexAttribArray(coordLocation);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // look up uniform locations
        colorLocation = gl.getUniformLocation(shaderProgram, "uColor");
        modelMatrixLoc = gl.getUniformLocation(shaderProgram, "uModelMatrix");
        viewMatrixLoc = gl.getUniformLocation(shaderProgram,"uViewMatrix");

        // Set a random color.
        //gl.uniform4f(colorLocation, 1, 0, 0, 1);

        // renderizamos el frame
        
        gl.enable(gl.DEPTH_TEST);

        render();
      }

      function render() {
        //========= STEP 4: Create the geometry and draw ===============

        // Clear the canvas
        gl.clearColor(0.3, 0.8, 0.5, 1.0);

        // Clear the color buffer bit
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Set the view port
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Bind appropriate array buffer to it
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

        // draw things

        // perspective
        viewMatrix = mat4.create();
        mat4.perspective(viewMatrix, Math.PI/4, 1, 1, 30);
        gl.uniformMatrix4fv(viewMatrixLoc, false, viewMatrix); 
        
        // Set the model Matrix.
        modelMatrix = mat4.create();
        mat4.identity(modelMatrix);
        eye = [player.x, player.y, player.z];
        v = [player.x + Math.cos(player.ori), player.y, player.z + Math.sin(player.ori)];
        mat4.lookAt(modelMatrix,
          eye,
          v,
          [0,1,0] // up vector
        );
        
        // transformations from GUI and mouse
        mat4.scale(modelMatrix, modelMatrix, [zoomFactor, zoomFactor,
        zoomFactor]);

        // rotate scene
        mat4.rotateY(modelMatrix, modelMatrix, rotateY);
        mat4.rotateX(modelMatrix, modelMatrix, rotateX);

        playerJump();
        updateBullets();
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
        glRenderCubeIBO(cube1.colorEdges, cube1.colorCube);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        
        DrawMovingCube(cube2, [-2.5, 1, -3], [-2.5, 1, cube2.speed[2]], 3, -3)
        
        DrawCube(cube3, [-2.5, 0, -3]);
        DrawCube(cube4, [-2.5, 0, 3]);
        DrawCube(cube5, [2.5, 0, -3]);
        DrawCube(cube6, [2.5, 4, -3]);
        
        DrawMovingCube(cube7, [2.5, 1, -3], [2.5, cube7.speed[1], -3], 3, 1)
        
        DrawCube(cube8, [2.5, 0, 3]);
        DrawCube(cube9, [2.5, 4, 3]);
        
        DrawMovingCube(cube10, [2.5, 1, -3], [2.5, cube10.speed[1], 3], 3, 1)
        DrawMovingCube(cube11, [-2.5, 3, -3], [-2.5, 3, cube11.speed[2]], 3, -3)
        
        DrawCube(cube12, [-2.5, 4, -3]);
        DrawCube(cube13, [-2.5, 4, 3]);
        
        DrawEnemy(enemy1);
        DrawEnemy(enemy2);
        DrawEnemy(enemy3);
        
        // drawGround
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
        glRenderCubeIBO(cube1.colorEdges, cube1.colorCube);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        glRenderGround(9, 10);

        // Unbind the buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        // empezamos bucle animación
        window.requestAnimationFrame(render);
      }

      function drawSquare() {
        v = new Float32Array([
          -0.5, 0.5, 0.5, 0.5, -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5,
        ]);
        // Pass the vertex data to the buffer
        gl.bufferData(gl.ARRAY_BUFFER, v, gl.STATIC_DRAW);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      function glRenderCubeIBO(colorEdges, colorCube) {
        glPushMatrix();
        mat4.translate(modelMatrix, modelMatrix, [-0.5, 0, -0.5]);
        gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
        // create vertices
        var arrayV = new Float32Array([
          0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1,
          1,
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, arrayV, gl.STATIC_DRAW);

        // draw edges
        var arrayI = new Uint16Array([
          0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
          7,
        ]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayI, gl.STATIC_DRAW);
        gl.uniform4fv(colorLocation, colorEdges);
        gl.drawElements(gl.LINES, 24, gl.UNSIGNED_SHORT, 0);

        // draw faces
        var arrayF = new Uint16Array([
        1,0,3, 1,3,2, // cara trasera
        4,5,6, 4,6,7, // cara delantera
        7,6,2, 7,2,3, // cara superior
        0,1,5, 0,5,4, // cara inferior
        5,1,2, 5,2,6, // cara derecha
        0,4,7, 0,7,3, // cara izquierda
                                 ]);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrayF, gl.STATIC_DRAW);
        gl.uniform4fv(colorLocation, colorCube);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

        glPopMatrix();
      }
      
      // draw squared floor
      function glRenderGround(size, n) {
       glPushMatrix();
         mat4.scale(modelMatrix, modelMatrix, [size, size, size]);
         mat4.translate(modelMatrix, modelMatrix, [-0.5, 0, -0.5]);
         gl.uniformMatrix4fv(modelMatrixLoc, false, modelMatrix);
         // creamos vector vértices
         var k = 0;
         var arrayV = new Float32Array(12*n);
         for (var i = 0; i < n; i++) {
           arrayV[k++] = i/(n-1);
           arrayV[k++] = 0;
           arrayV[k++] = 0;
           arrayV[k++] = i/(n-1);
           arrayV[k++] = 0;
           arrayV[k++] = 1;
         }
         for (i = 0; i <= n; i++) {
           arrayV[k++] = 0;
           arrayV[k++] = 0;
           arrayV[k++] = i/(n-1);
           arrayV[k++] = 1;
           arrayV[k++] = 0;
           arrayV[k++] = i/(n-1);
         }
         gl.bufferData(gl.ARRAY_BUFFER, arrayV, gl.STATIC_DRAW);
         gl.drawArrays(gl.LINES, 0, 4*n);
         //delete arrayV;
       glPopMatrix();
      }
      
      function DrawCube(cube, position){
        glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, position);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
          glRenderCubeIBO(cube.colorEdges, cube.colorCube);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        glPopMatrix();
      }
      
      function DrawMovingCube(cube, position, newPosition, upperBound, lowerBound){
        glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, position);
          glPopMatrix();
          glPushMatrix();
          mat4.translate(modelMatrix, modelMatrix, newPosition);
          if (cube.speed[1] !== 0){
            cube.speed[1] += cube.movement;
            checkMovementDirection(cube, upperBound, lowerBound, true, false);
          }
          else if (cube.speed[2] !== 0){
            cube.speed[2] += cube.movement;
            checkMovementDirection(cube, upperBound, lowerBound, false, true);
          }
        
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
          glRenderCubeIBO(cube.colorEdges, cube.colorCube);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        glPopMatrix();
      }
      
      function checkMovementDirection(cube, upperBound, lowerBound, Ymovement, Zmovement){
        if (Ymovement === true && Zmovement === false){
          if (cube.speed[1] >= upperBound || cube.speed[1] <= lowerBound){
            cube.movement *= -1;
          }
        }
        else if (Ymovement === false && Zmovement === true){
          if (cube.speed[2] >= upperBound || cube.speed[2] <= lowerBound){
            cube.movement *= -1;
          }
        }
      }
      
      function DrawEnemy(enemy){
        if (enemy.dead === false){
          glPushMatrix();
            mat4.translate(modelMatrix, modelMatrix, enemy.position);
            mat4.scale(modelMatrix, modelMatrix, [0.5, 0.5, 0.5]);
            chasePlayer(enemy);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            glRenderCubeIBO(enemy.colorEdges, enemy.colorCube);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          glPopMatrix();
        }
      }
      
      function chasePlayer(enemy){
        let distX = player.x - enemy.position[0];
        let distY = player.y - enemy.position[1];
        let distZ = player.z - enemy.position[2];
        
        let direction = [distX, distY, distZ];
        
        let distance = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
        if (distance > 0) {
            direction[0] /= distance;
            direction[1] /= distance;
            direction[2] /= distance;
        }
        
        if (distance > 0.1){
          enemy.position[0] += direction[0] * enemy.movement;
          //enemy.position[1] += direction[1] * enemy.movement;
          enemy.position[2] += direction[2] * enemy.movement;
        }
      }
      
      function playerJump(){
        if (player.isJumping === true){
          player.y += player.jumpSpeed;
        }

        if (player.y > 0.5){
          player.jumpSpeed -= 0.005;
        }
        else{
          player.jumpSpeed = 0;
          player.isJumping = false;
        }
      }
      
      function shoot(){
        bullets.push({
          x: player.x + 0.1 * Math.cos(player.ori),
          y: 0.25,
          z: player.z + 0.1 * Math.sin(player.ori),
          directionX: Math.cos(player.ori),
          directionZ: Math.sin(player.ori),
          speed: 0.2
        });
      }
      
      function updateBullets(){
        if (bullets.length > 0){
          for (let i = 0; i < bullets.length; i++) {
            let bullet = bullets[i];

            bullet.x += bullet.directionX * bullet.speed;
            bullet.z += bullet.directionZ * bullet.speed;

            if (hitEnemy(bullet, enemy1) && enemy1.dead === false){
              enemy1.dead = true;
              bullets.splice(i,1);
            }
            if (hitEnemy(bullet, enemy2) && enemy2.dead === false){
              enemy2.dead = true;
              bullets.splice(i,1);
            }
            if (hitEnemy(bullet, enemy3) && enemy3.dead === false){
              enemy3.dead = true;
              bullets.splice(i,1);
            }
            
            glPushMatrix();
              mat4.translate(modelMatrix, modelMatrix, [bullet.x, bullet.y, bullet.z]);
              mat4.scale(modelMatrix, modelMatrix, [0.08, 0.08, 0.08]);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
              glRenderCubeIBO([0, 0, 0, 1], [1, 1, 1, 1]);
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            glPopMatrix();
          }
        }
      }
      
      function hitEnemy(bullet, enemy){
        let distX = bullet.x - enemy.position[0];
        let distY = bullet.y - enemy.position[1];
        let distZ = bullet.z - enemy.position[2];
        
        let distance = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
        
        if (distance < 0.5){
          return true;
        }
        else{
          return false;
        }
      }

      // Call init once the document has loaded
      window.onload = init;

      // add mouse handlers
      document.onmousedown = onMouseDown;
      document.onmousemove = onMouseMove;
      document.onwheel = zoom;
      document.onkeydown = onKeyDown;

      function onMouseDown(e) {
        if (e.buttons == 1 && e.srcElement == canvas) {
          mouseX = e.pageX;
          mouseY = e.pageY;
        }
      }

      function onMouseMove(e) {
        if (e.buttons == 1 && e.srcElement == canvas) {
          rotateY = rotateY + (e.pageX - mouseX) * 0.01;
          rotateX = rotateX + (e.pageY - mouseY) * 0.01;
          mouseX = e.pageX;
          mouseY = e.pageY;
          //console.log("move = ("+mouseX+","+mouseY+")");
        }
      }
      
      function onKeyDown(key) {
       //console.log(key.keyCode)
       switch (key.keyCode) {
         // W
         case 87: {
           player.x = player.x + 0.1 * Math.cos(player.ori);
           player.z = player.z + 0.1 * Math.sin(player.ori);
           break;
         }
         // S
         case 83: {
           player.x = player.x - 0.1 * Math.cos(player.ori);
           player.z = player.z - 0.1 * Math.sin(player.ori);
           break;
         }
         // A
         case 65: {
         player.ori -= 0.02;
         break;
         }
         // D
         case 68: {
           player.ori += 0.02;
           break;
         }
         // Spacebar
         case 32: {
           if (player.isJumping === false){
             player.jumpSpeed = 0.1;
             player.isJumping = true;
           }
           break;
        }
        // E
        case 69: {
           shoot();
           break;
        }
       }
      }
      
      function zoom(e) {
       if (e.deltaY<0)
       zoomFactor *= 1.1;
       else
       zoomFactor *= 0.9;
      }
      
    </script>
  </body>
</html>
